<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-0.9.584">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dr.&nbsp;Gilbert and Dr.&nbsp;Duryea">

<title>Finding the Replication Origin, Part II</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="ReplicationOrigin_PartII_files/libs/clipboard/clipboard.min.js"></script>
<script src="ReplicationOrigin_PartII_files/libs/quarto-html/quarto.js"></script>
<script src="ReplicationOrigin_PartII_files/libs/quarto-html/popper.min.js"></script>
<script src="ReplicationOrigin_PartII_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ReplicationOrigin_PartII_files/libs/quarto-html/anchor.min.js"></script>
<link href="ReplicationOrigin_PartII_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ReplicationOrigin_PartII_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ReplicationOrigin_PartII_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ReplicationOrigin_PartII_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ReplicationOrigin_PartII_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Finding the Replication Origin, Part II</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Dr.&nbsp;Gilbert and Dr.&nbsp;Duryea </p>
          </div>
  </div>
    
    
  </div>
  

</header>

<section id="preliminary-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="preliminary-thoughts">Preliminary Thoughts</h2>
<p>Welcome back! We’ve done a lot of work and made quite a bit of headway so far. As a reminder, our goal through this first chapter is to identify the location of the replication origin within a genome. Up to this point we’ve had a crash course in computing, encountering looping mechanisms (<code>for</code> loops), programmatic flow control (<code>if</code>/<code>else if</code>/<code>else</code> statements), and developed an ability to write reusable code blocks in the form of <em>functions</em>. We’ve applied all of these techniques to help us in analysing genomes (mostly fake/random genomes that we’ve generated, but we’ll get to real bacterial genomes soon). Our work thus far has culminated in a pair of functions <code>generate_k_mers()</code>, which will generate all strings of <code>k</code> consecutive nucleotides within a genome, and <code>count_patterns()</code> which will count the number of occurrences of a particular <code>pattern</code> within a <code>genome</code>. Let’s pick back up from here.</p>
<p>Open RStudio and open the project that is managing your group repository. Open the Quarto Notebook you were working on last time and re-run the code cells which build the <code>generate_k_mers()</code> and <code>count_pattern()</code> functions – you can simply run all of the code chunks if you’d like. You’ll be adding on to that notebook today.</p>
</section>
<section id="towards-identification-of-the-replication-origin" class="level2">
<h2 class="anchored" data-anchor-id="towards-identification-of-the-replication-origin">Towards Identification of the Replication Origin</h2>
<p>Remember from General Biology that DNA replication begins at a certain position in the genome called the origin. The origin consists of a specific set of DNA sequences that signal to the cell’s machinery the correct position to start replication. In bacteria, one of the proteins that helps with replication is called <em>DnaA</em>. This protein binds to sequences in the genome called <em>DnaA boxes</em>, which are strings of 9 nucleotides that are repeated more frequently around the origin of replication.</p>
<p>Armed with the knowledge that these DnaA boxes appear more frequently than one would expect a random sequence of 9 nucleotides to appear, we know that we are searching for frequently occurring 9-mers. Can you combine your <code>generate_k_mers()</code> and <code>count_patterns()</code> functions into a new function called <code>generate_frequent_k_mers()</code> that will build a list of the most frequent <code>k</code>-mers? Your function should take two parameters, <code>genomeString</code> and <code>k</code>.</p>
<hr>
<p><strong>Challenge 1:</strong> Find the most frequent words in a string</p>
<blockquote class="blockquote">
<p><strong><em>Input:</em></strong> A DNA string (<code>genomeString</code>) and an integer <code>k</code><br>
<strong><em>Output:</em></strong> A list containing the most frequent <code>k</code>-mers in <code>genomeString</code>. Note that your list should contain each <code>k</code>-mer at most once.<br>
<em>Hint</em>: Use the <code>unique()</code> function on your list of <code>k</code>-mers before returning the object.</p>
</blockquote>
<hr>
<p>To begin this challenge, let’s practice with a small genome . Copy over your <code>generate_k_mers</code> function and run it on the sequence <code>ACACAGACATCCCACCCC</code> and consider 3-mers.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Use this code chunk to run your generate_k_mers function</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Your function should return a list of several 3-mers, but you should notice that some 3-mers (<code>ACA</code> and <code>CCC</code>) are repeated. These are the 3-mers that we want to count!</p>
<p>Now, with your group think about how you will combine your <code>generate_k_mers</code> function with your <code>count_ pattern</code> function so that it will count and return the most frequent <code>k</code>-mers. Before you get coding, talk with a group and generate a list of what you will need in this new function, <code>generate_frequent_kmers</code>. Think about:</p>
<ul>
<li><p>How can you use your existing <code>generate_k_mers</code> function to generate a list of <code>k</code>-mers of length <code>k</code> from a <code>genomeString</code>? (Hint: you may need to store this as an <code>object</code> for your <code>generate_frequent_kmers</code> function.)</p></li>
<li><p>How can you use your <code>count_pattern</code> function to count this list of <code>k</code>-mers that you generated? (Hint: it may involve a <code>for</code> loop!).</p></li>
<li><p>How will you tell your function to return only the most frequent patterns? (Hint: think about the objects that you will need to define in your function, or what the function will be counting and returning. This is where the functions <code>unique()</code> and <code>max()</code> may be useful.)</p></li>
</ul>
<p>Think you’ve got it? Use the code chunk below to complete Challenge 1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Complete the challenge here</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once you’re confident that your function works, head back over to Rosalind and try solving the <a href="http://rosalind.info/problems/ba1b/" target="_blank">Frequent Words Problem</a>. Test your code on the sample data set first – if it works, click the link to download the challenge data set and see if you can generate the correct output. As a reminder, the code to read the data into R is below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">scan</span>(<span class="st">"PATH_TO_FILE"</span>, <span class="at">what =</span> <span class="fu">character</span>())</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#The genomeString</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>genomeString <span class="ot">&lt;-</span> data[<span class="dv">1</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>genomeString</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">#The value of k</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(data[<span class="dv">2</span>])</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>k</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To automatically generate the output in the format Rosalind wants it (all k-mers on one line, each separated by a space), you can use the following.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>freq_k_mers <span class="ot">&lt;-</span> <span class="fu">generate_frequent_k_mers</span>(genomeString, k)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">noquote</span>(freq_k_mers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The code stores the list of most frequent k-mers into the object freq_k_mers and then says that we should print each of these k-mers out with no quotation marks around them.</p>
<p>Great work. Now that we are feeling good about ourselves, things are going to get messy. Unfortunately the nucleotides in these DnaA boxes we are looking for, don’t always appear in the same way. For example, just like humans make mistakes while typing, DNA polymerase can make mistakes while it replicates the genome – what if one of the base pairs wasn’t copied correctly during the previous round of replication? Additionally, the replication signal we are looking for may appear as both the k-mer signaling that replication should begin, or as its reverse complement. Because of this, we’ll need to build code that is flexible enough to count reverse complements as well as near k-mers (with some pre-defined number of discrepancies allowed). Let’s get on it.</p>
<p>We’ll start with the reverse complement problem. Recall from gen-bio that A and T are complementary base pairs, as well as G and C. This means that in double-stranded DNA, we should see across from each Adenine (A) a Thymine (T), across from each Cytosine (C) a Guanine (G), and vice-versa. This means that if we look across from a segment of DNA, we can see the reverse complement of that segment. The “reverse” refers to the fact that the complementary sequence is also anti-parallel, meaning 5’ and 3’ ends are oriented in opposite directions on each side of the double strand. Thus, we read the complementary sequence in reverse order. For example, the reverse complement of <code>ACCTGA</code> is <code>TCAGGT</code>.</p>
<p>Let’s write a function to compute the <code>reverse_complement()</code> of a <code>genomeSubString</code>. While you’re at it, solve your third Rosalind challenge.</p>
<hr>
<p><strong>Challenge 2:</strong> The <a href="http://rosalind.info/problems/ba1c/" target="_blank">Reverse-Complement Problem</a></p>
<blockquote class="blockquote">
<p><strong>Input:</strong> A pattern of nucleotides called <code>genomeSubString</code><br>
<strong>Output:</strong> The reverse-complement of <code>genomeSubString</code></p>
</blockquote>
<hr>
<p>Like you did with Challenge 1, think about what your function will need to do and what existing tools you have to use. Talk through this with your group before you begin. Here are some hints:</p>
<ul>
<li><p>You might need the function <code>rev()</code>. Pull up your <code>randgenome</code> function and test out how <code>rev</code>() works on a genome that you generate. How is this useful to the reverse complement problem? How can you build this into your function?</p></li>
<li><p>To get the complement of your genome, you may need to use <code>if/else</code> statements. Review what you know about these and think about how you need to use them in your <code>reverse_complement</code> function.</p></li>
</ul>
<p>Think you got it? Test out your code below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Complete the challenge here</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<!-- The efficiency of our code can make a really big difference in our ability to solve problems at the scale of real genomes (millions of nucleotides in length). We'll start paying a bit more attention to ways we might be able to speed up our functions (and clean up our code too). While running slow code on our examples so far hasn't been much of a problem, if we run a series of slow functions on a full genome (say 4 million nucleotides), we may end up with code that takes hours, days, or even weeks to run! -->
<!-- Let's see a way to speed up (and clean up) our `reverse_complement()` function below (we'll do this together). -->
<!-- ```{r eval = FALSE} -->
<!-- library(Dict) -->
<!-- #We'll update the function together -->
<!-- ``` -->
<!-- *Note that we had left last year:* The fourth Rosalind problem ([Find all occurrences of a pattern in a string](https://rosalind.info/problems/ba1d/){target="_blank"}) may be a really good homework problem. It doesn't really follow the reverse complement problem -- what do you think about assigning it for them to complete outside of class? I wonder if we could made an assignment out of pages 12-13 in the book -- having them write about why pattern matching is important and how just because we have a frequently occurring k-mer/9-mer this doesn't necessarily mean we have found a DnaA box, and then having them try to solve the coding challenge. -->
</section>
<section id="summary-and-debrief" class="level2">
<h2 class="anchored" data-anchor-id="summary-and-debrief">Summary and Debrief</h2>
<p>We’ve made quite a bit of headway! We’re able to search a genome for frequent “near”-k-mers and their reverse-complements. These are the genetic substrings which will signal replication to the DNA polymerase. Next time, we’ll look at narrowing down the area we should be looking in for the replication origin. We’ll exploit properties of genetic transcription and mutation to solve this.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      let href = ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>